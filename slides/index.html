<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Majin Marp Editor</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dialog-polyfill@0.5.6/dist/dialog-polyfill.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700;900&display=swap" rel="stylesheet">
  </head>
  <body>
    <header class="toolbar">
      <div class="left">
        <button id="btn-new" onclick="window.__newDoc && window.__newDoc()">新規</button>
        <button id="btn-open" onclick="window.__openFile && window.__openFile()">開く(.md)</button>
        <button id="btn-save-md" onclick="window.__saveMd && window.__saveMd()">保存(.md)</button>
        <button id="btn-download-html" onclick="window.__saveHtml && window.__saveHtml()">ダウンロード(.html)</button>
      </div>
      <div class="right">
        <button id="btn-dispatch" onclick="window.__dispatch && window.__dispatch()">Googleスライド化(ワンクリック)</button>
        <button id="btn-google-auth" onclick="window.__authGoogle && window.__authGoogle()">Googleにサインイン</button>
        <button id="btn-direct-gslides" onclick="window.__direct && window.__direct()">Secrets不要で直送</button>
        <button id="btn-settings" onclick="window.__openSettings && window.__openSettings()">設定</button>
      </div>
      <input id="file-open" type="file" accept=".md,.markdown,.txt" hidden />
    </header>

    <main class="split">
      <section class="pane editor-pane">
        <textarea id="editor" spellcheck="false"></textarea>
      </section>
      <section class="pane preview-pane">
        <div id="preview" class="preview"></div>
      </section>
    </main>

    <dialog id="dlg-settings">
      <form method="dialog" class="settings-form">
        <h3>GitHub / Googleスライド 連携設定</h3>
        <label>GitHub Owner<input id="gh-owner" placeholder="your-account-or-org" /></label>
        <label>GitHub Repo<input id="gh-repo" placeholder="your-repo" /></label>
        <label>ブランチ(ref)<input id="gh-ref" placeholder="main" /></label>
        <label>Workflow ファイル名<input id="gh-workflow" placeholder="slides.yml" /></label>
        <label>保存パス(.md)<input id="gh-md-path" placeholder="slides/majin-${timestamp}.md" /></label>
        <label>GitHub PAT(Token)<input id="gh-token" type="password" placeholder="ghp_... (repo権限)" /></label>
        <hr />
        <label>Google OAuth Client ID<input id="gcp-client-id" placeholder="xxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com" /></label>
        <label>Google Drive Folder ID(任意)<input id="gdrive-folder" placeholder="フォルダに入れる場合" /></label>
        <label>共有メール(任意・編集者付与)<input id="share-email" placeholder="you@example.com" /></label>
        <menu>
          <button id="btn-settings-cancel">閉じる</button>
          <button id="btn-settings-save" value="default">保存</button>
        </menu>
      </form>
    </dialog>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/dialog-polyfill@0.5.6/dist/dialog-polyfill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script type="module">
      import Marp from 'https://cdn.jsdelivr.net/npm/@marp-team/marp-core@4.0.2/lib/marp.esm.js';

      const $ = (sel) => document.querySelector(sel);
      const editor = $('#editor');
      const preview = $('#preview');
      const dlg = $('#dlg-settings');

      const DEFAULT_MD = `---\nmarp: true\ntheme: majin\npaginate: true\nsize: 16:9\n---\n\n# まじん式スライド\n\n- 左で編集 / 右でプレビュー\n- 「ダウンロード(.html)」で単一HTMLを書き出し\n- 「Googleスライド化」ボタンでGitHub Actionsを起動\n`;

      // Load theme CSS
      let themeCSS = '';
      fetch('./themes/majin.css').then(r => r.text()).then(css => { themeCSS = css; tryRender(); });

      const marp = new Marp({ html: true, markdown: { breaks: true } });
      const themeSet = [ { name: 'majin', css: () => themeCSS } ];

      function tryRender() {
        if (!editor) return;
        try {
          const { html, css } = marp.render(editor.value || '', { themeSet });
          preview.innerHTML = `<style>${css}</style>` + html;
        } catch (e) {
          preview.innerHTML = `<pre class="error">${e.message}</pre>`;
        }
      }

      // Persistence
      const LS_KEY = 'majin-marp-md';
      if (editor) {
        editor.value = localStorage.getItem(LS_KEY) || DEFAULT_MD;
        editor.addEventListener('input', () => { localStorage.setItem(LS_KEY, editor.value); tryRender(); });
      }

      function readCfg() {
        return {
          owner: localStorage.getItem('gh.owner') || 'shoei05',
          repo: localStorage.getItem('gh.repo') || 'majinslides',
          ref: localStorage.getItem('gh.ref') || 'main',
          workflow: localStorage.getItem('gh.workflow') || 'slides.yml',
          mdPath: localStorage.getItem('gh.mdPath') || '改良版 まじん式プロンプト.md',
          token: localStorage.getItem('gh.token') || '',
          folderId: localStorage.getItem('gdrive.folderId') || '',
          shareEmail: localStorage.getItem('gdrive.shareEmail') || '',
          googleClientId: localStorage.getItem('gcp.clientId') || '',
        };
      }
      function writeCfg(cfg) {
        localStorage.setItem('gh.owner', cfg.owner);
        localStorage.setItem('gh.repo', cfg.repo);
        localStorage.setItem('gh.ref', cfg.ref);
        localStorage.setItem('gh.workflow', cfg.workflow);
        localStorage.setItem('gh.mdPath', cfg.mdPath);
        localStorage.setItem('gh.token', cfg.token);
        localStorage.setItem('gdrive.folderId', cfg.folderId);
        localStorage.setItem('gdrive.shareEmail', cfg.shareEmail);
        localStorage.setItem('gcp.clientId', cfg.googleClientId || '');
      }

      function openSettings() {
        const c = readCfg();
        $('#gh-owner').value = c.owner;
        $('#gh-repo').value = c.repo;
        $('#gh-ref').value = c.ref;
        $('#gh-workflow').value = c.workflow;
        $('#gh-md-path').value = c.mdPath;
        $('#gh-token').value = c.token;
        $('#gdrive-folder').value = c.folderId;
        $('#share-email').value = c.shareEmail;
        const gci = $('#gcp-client-id'); if (gci) gci.value = c.googleClientId;
        try { if (!('showModal' in dlg)) window.dialogPolyfill && window.dialogPolyfill.registerDialog(dlg); dlg.showModal(); }
        catch { dlg.setAttribute('open',''); }
      }
      function saveSettings() {
        writeCfg({
          owner: $('#gh-owner').value.trim(),
          repo: $('#gh-repo').value.trim(),
          ref: $('#gh-ref').value.trim() || 'main',
          workflow: $('#gh-workflow').value.trim() || 'slides.yml',
          mdPath: $('#gh-md-path').value.trim() || 'slides/majin-${timestamp}.md',
          token: $('#gh-token').value.trim(),
          folderId: $('#gdrive-folder').value.trim(),
          shareEmail: $('#share-email').value.trim(),
          googleClientId: (function(){ const el = $('#gcp-client-id'); return el ? (el.value || '').trim() : ''; })(),
        });
        try { dlg.close(); } catch { dlg.removeAttribute('open'); }
      }

      async function commitMarkdown(cfg) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const mdPath = (cfg.mdPath || 'slides/majin-${timestamp}.md').replace('${timestamp}', timestamp);
        const api = 'https://api.github.com';
        const headers = { 'Authorization': `Bearer ${cfg.token}`, 'Accept': 'application/vnd.github+json' };
        const contentB64 = btoa(unescape(encodeURIComponent(editor.value)));
        const putUrl = `${api}/repos/${cfg.owner}/${cfg.repo}/contents/${encodeURIComponent(mdPath)}`;
        let sha = '';
        const head = await fetch(putUrl + `?ref=${encodeURIComponent(cfg.ref)}`, { headers });
        if (head.ok) { const info = await head.json(); sha = info.sha || ''; }
        const body = { message: (sha ? 'chore(slides): update ' : 'feat(slides): add ') + mdPath, content: contentB64, branch: cfg.ref };
        if (sha) body.sha = sha;
        const resPut = await fetch(putUrl, { method: 'PUT', headers, body: JSON.stringify(body) });
        if (!resPut.ok) throw new Error('ファイル登録失敗: ' + (await resPut.text()));
        return mdPath;
      }

      async function triggerWorkflow(cfg) {
        const api = 'https://api.github.com';
        const headers = { 'Authorization': `Bearer ${cfg.token}`, 'Accept': 'application/vnd.github+json' };
        const wfUrl = `${api}/repos/${cfg.owner}/${cfg.repo}/actions/workflows/${encodeURIComponent(cfg.workflow)}/dispatches`;
        const resWf = await fetch(wfUrl, { method: 'POST', headers, body: JSON.stringify({ ref: cfg.ref }) });
        if (!resWf.ok) throw new Error('Workflow起動失敗: ' + (await resWf.text()));
      }

      async function fetchJson(url, headers) { const r = await fetch(url, { headers }); if (!r.ok) throw new Error(`${r.status} ${url}`); return r.json(); }

      async function waitAndFetchPptxArtifact(cfg, startedAtMs, timeoutMs=180000) {
        const api = 'https://api.github.com';
        const headers = { 'Authorization': `Bearer ${cfg.token}`, 'Accept': 'application/vnd.github+json' };
        const deadline = Date.now() + timeoutMs;
        const sinceIso = new Date(startedAtMs - 5000).toISOString();
        while (Date.now() < deadline) {
          const runs = await fetchJson(`${api}/repos/${cfg.owner}/${cfg.repo}/actions/runs?per_page=10`, headers);
          const ok = (runs.workflow_runs || []).find(r => r.path === `.github/workflows/${cfg.workflow}` && r.status === 'completed' && r.conclusion === 'success' && r.run_started_at >= sinceIso);
          if (ok) {
            const arts = await fetchJson(`${api}/repos/${cfg.owner}/${cfg.repo}/actions/runs/${ok.id}/artifacts?per_page=10`, headers);
            const a = (arts.artifacts || []).find(x => x.name === 'majin-slides');
            if (a) {
              const zipRes = await fetch(a.archive_download_url, { headers });
              const zipBlob = await zipRes.blob();
              const zip = await JSZip.loadAsync(zipBlob);
              const entry = Object.values(zip.files).find(f => f.name.endsWith('dist/slides.pptx'));
              if (!entry) throw new Error('PPTXがアーティファクトに見つかりません');
              const buf = await entry.async('arraybuffer');
              return { blob: new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' }), name: 'slides.pptx' };
            }
          }
          await new Promise(r => setTimeout(r, 4000));
        }
        throw new Error('Artifactsの取得にタイムアウトしました');
      }

      // Google OAuth (client-side)
      let googleAccessToken = '';
      async function ensureGoogleToken(interactive=false) {
        const cfg = readCfg();
        if (!cfg.googleClientId) { openSettings(); alert('Google OAuth Client ID を設定してください'); return null; }
        if (googleAccessToken && !interactive) return googleAccessToken;
        return new Promise((resolve, reject) => {
          try {
            const tokenClient = google.accounts.oauth2.initTokenClient({
              client_id: cfg.googleClientId,
              scope: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/presentations',
              callback: (resp) => { if (resp && resp.access_token) { googleAccessToken = resp.access_token; resolve(googleAccessToken); } else reject(new Error('No access_token')); },
            });
            tokenClient.requestAccessToken();
          } catch (e) { console.error(e); alert('Google認証に失敗しました'); reject(e); }
        });
      }

      async function uploadPptxAsSlides(accessToken, pptxBlob, folderId, title) {
        const boundary = '-------majinslides' + Math.random().toString(16).slice(2);
        const metadata = { name: title, mimeType: 'application/vnd.google-apps.presentation', parents: folderId ? [folderId] : undefined };
        const body = new Blob([
          `--${boundary}\r\n`, 'Content-Type: application/json; charset=UTF-8\r\n\r\n', JSON.stringify(metadata) + '\r\n',
          `--${boundary}\r\n`, 'Content-Type: application/vnd.openxmlformats-officedocument.presentationml.presentation\r\n\r\n', pptxBlob, `\r\n--${boundary}--`
        ], { type: 'multipart/related; boundary=' + boundary });
        const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id', { method: 'POST', headers: { 'Authorization': `Bearer ${accessToken}` }, body });
        if (!res.ok) throw new Error('Driveアップロード失敗: ' + (await res.text()));
        const { id } = await res.json();
        return { id, webLink: `https://docs.google.com/presentation/d/${id}/edit` };
      }

      async function grantPermission(accessToken, fileId, email) {
        const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions?sendNotificationEmail=false`, { method: 'POST', headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ role: 'writer', type: 'user', emailAddress: email }) });
        if (!res.ok) throw new Error('権限付与失敗: ' + (await res.text()));
      }

      async function dispatchWorkflow() {
        const cfg = readCfg();
        if (!cfg.owner || !cfg.repo || !cfg.token) { openSettings(); alert('GitHub設定が不足しています。Owner/Repo/Tokenを設定してください。'); return; }
        try {
          await commitMarkdown(cfg);
          await triggerWorkflow(cfg);
          alert('Workflowを起動しました。完了後、ActionsのArtifactsからPDF/PPTX/HTMLが取得できます。');
        } catch (e) { alert(e.message || String(e)); }
      }

      async function dispatchAndDirectConvert() {
        const cfg = readCfg();
        if (!cfg.owner || !cfg.repo || !cfg.token) { openSettings(); alert('GitHub設定が不足しています'); return; }
        const started = Date.now();
        try {
          await commitMarkdown(cfg);
          await triggerWorkflow(cfg);
          const { blob } = await waitAndFetchPptxArtifact(cfg, started);
          const token = await ensureGoogleToken(true);
          const link = await uploadPptxAsSlides(token, blob, cfg.folderId || '', `Majin Slides ${new Date().toLocaleString()}`);
          if (cfg.shareEmail) { try { await grantPermission(token, link.id, cfg.shareEmail); } catch (e) { console.warn('permission failed', e); } }
          window.open(link.webLink, '_blank');
        } catch (e) { alert(e.message || String(e)); }
      }

      function attachHandlers() {
        const bNew = $('#btn-new'); if (bNew) bNew.addEventListener('click', () => { if (!editor) return; editor.value = DEFAULT_MD; editor.dispatchEvent(new Event('input')); });
        const bOpen = $('#btn-open'); if (bOpen) bOpen.addEventListener('click', () => { const fo = $('#file-open'); if (fo) fo.click(); });
        const fOpen = $('#file-open'); if (fOpen) fOpen.addEventListener('change', async (e) => { const f = e.target && e.target.files ? e.target.files[0] : null; if (!f) return; const text = await f.text(); editor.value = text; editor.dispatchEvent(new Event('input')); });
        const bSave = $('#btn-save-md'); if (bSave) bSave.addEventListener('click', () => { const blob = new Blob([editor.value], { type: 'text/markdown;charset=utf-8' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'majin-slides.md'; a.click(); URL.revokeObjectURL(a.href); });
        const bHtml = $('#btn-download-html'); if (bHtml) bHtml.addEventListener('click', () => { const { html, css } = marp.render(editor.value, { themeSet }); const doc = `<!doctype html><html lang=\"ja\"><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><title>Majin Slides</title><style>${css}</style>${html}`; const blob = new Blob([doc], { type: 'text/html;charset=utf-8' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'majin-slides.html'; a.click(); URL.revokeObjectURL(a.href); });
        const bSet = $('#btn-settings'); if (bSet) bSet.addEventListener('click', openSettings);
        const bSetCancel = $('#btn-settings-cancel'); if (bSetCancel) bSetCancel.addEventListener('click', () => { try { dlg.close(); } catch (e) { dlg.removeAttribute('open'); } });
        const bSetSave = $('#btn-settings-save'); if (bSetSave) bSetSave.addEventListener('click', saveSettings);
        const bDispatch = $('#btn-dispatch'); if (bDispatch) bDispatch.addEventListener('click', () => dispatchWorkflow());
        const bAuth = $('#btn-google-auth'); if (bAuth) bAuth.addEventListener('click', () => ensureGoogleToken(true));
        const bDirect = $('#btn-direct-gslides'); if (bDirect) bDirect.addEventListener('click', () => dispatchAndDirectConvert());

        // expose fallbacks for inline onclick
        window.__newDoc = () => { if (!editor) return; editor.value = DEFAULT_MD; editor.dispatchEvent(new Event('input')); };
        window.__openFile = () => { const fo = $('#file-open'); if (fo) fo.click(); };
        window.__saveMd = () => { const blob = new Blob([editor.value], { type: 'text/markdown;charset=utf-8' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'majin-slides.md'; a.click(); URL.revokeObjectURL(a.href); };
        window.__saveHtml = () => { const { html, css } = marp.render(editor.value, { themeSet }); const doc = `<!doctype html><html lang=\"ja\"><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><title>Majin Slides</title><style>${css}</style>${html}`; const blob = new Blob([doc], { type: 'text/html;charset=utf-8' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'majin-slides.html'; a.click(); URL.revokeObjectURL(a.href); };
        window.__openSettings = openSettings;
        window.__dispatch = () => dispatchWorkflow();
        window.__authGoogle = () => ensureGoogleToken(true);
        window.__direct = () => dispatchAndDirectConvert();
      }

      window.addEventListener('DOMContentLoaded', () => { tryRender(); attachHandlers(); });
    </script>
  </body>
  </html>
